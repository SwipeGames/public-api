// Package coreapiv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package coreapiv1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
	externalRef0 "github.com/swipegames/public-api/api/v1.0"
)

// Defines values for CreateNewGameRequestPlatform.
const (
	Desktop CreateNewGameRequestPlatform = "desktop"
	Mobile  CreateNewGameRequestPlatform = "mobile"
)

// CreateNewGameRequest defines model for CreateNewGameRequest.
type CreateNewGameRequest struct {
	// CID Client's ID. It's provided by Swipe Games and is used as your idintifier.
	CID openapi_types.UUID `json:"cID"`

	// Currency Currency code in ISO4217.
	Currency string `json:"currency"`

	// Demo Demo mode. If true, the game will be launched in demo mode (means no callbacks will be fired on your side,
	// and we use our demo balance for the game). If false, the game will be launched in real mode.
	Demo *bool `json:"demo,omitempty"`

	// ExtCID External Client's ID (client/platform/game aggregator/integrator or casino on your side). This is provided from your side, and this is
	// how you identify your clients. We use it in all callbacks to you. Not required for demo games, since we don't use callbacks for demo games.
	ExtCID *string `json:"extCID,omitempty"`

	// GameID Game's ID. This is Swipe Games's game idintifier. See the list of supported games in `Game IDs` section.
	GameID string `json:"gameID"`

	// Language Language code in IIETF BCP 47 (ISO 639).
	Language *string `json:"language,omitempty"`

	// Platform Platform code. This is used to identify the platform where the game is launched.
	Platform *CreateNewGameRequestPlatform `json:"platform,omitempty"`

	// ReturnURL Return URL which we could use to redirect the user after the game is finished/exited. If you don't provide this URL, return button in the game will be disabled. Please make sure you provide this URL when using redirect to open the game, otherwise player cannot
	ReturnURL *string `json:"returnURL,omitempty"`

	// SessionID Session ID (game integrator or casino).This is your Session ID. We use
	// it in all callbacks to you. Not required for demo games, since we don't use callbacks for demo games.
	SessionID *string           `json:"sessionID,omitempty"`
	User      externalRef0.User `json:"user"`
}

// CreateNewGameRequestPlatform Platform code. This is used to identify the platform where the game is launched.
type CreateNewGameRequestPlatform string

// CreateNewGameResponse defines model for CreateNewGameResponse.
type CreateNewGameResponse struct {
	GameSessionId openapi_types.UUID `json:"game_session_id"`
	GameUrl       string             `json:"game_url"`
}

// PostCreateNewGameParams defines parameters for PostCreateNewGame.
type PostCreateNewGameParams struct {
	// XREQUESTSIGN Request signature (read more in the Authentication section)
	XREQUESTSIGN string `json:"X-REQUEST-SIGN"`
}

// PostCreateNewGameJSONRequestBody defines body for PostCreateNewGame for application/json ContentType.
type PostCreateNewGameJSONRequestBody = CreateNewGameRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostCreateNewGameWithBody request with any body
	PostCreateNewGameWithBody(ctx context.Context, params *PostCreateNewGameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCreateNewGame(ctx context.Context, params *PostCreateNewGameParams, body PostCreateNewGameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostCreateNewGameWithBody(ctx context.Context, params *PostCreateNewGameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateNewGameRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreateNewGame(ctx context.Context, params *PostCreateNewGameParams, body PostCreateNewGameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateNewGameRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostCreateNewGameRequest calls the generic PostCreateNewGame builder with application/json body
func NewPostCreateNewGameRequest(server string, params *PostCreateNewGameParams, body PostCreateNewGameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCreateNewGameRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCreateNewGameRequestWithBody generates requests for PostCreateNewGame with any type of body
func NewPostCreateNewGameRequestWithBody(server string, params *PostCreateNewGameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/create-new-game")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-REQUEST-SIGN", runtime.ParamLocationHeader, params.XREQUESTSIGN)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-REQUEST-SIGN", headerParam0)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostCreateNewGameWithBodyWithResponse request with any body
	PostCreateNewGameWithBodyWithResponse(ctx context.Context, params *PostCreateNewGameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateNewGameResponse, error)

	PostCreateNewGameWithResponse(ctx context.Context, params *PostCreateNewGameParams, body PostCreateNewGameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreateNewGameResponse, error)
}

type PostCreateNewGameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateNewGameResponse
	JSON401      *externalRef0.ErrorResponse
	JSON500      *externalRef0.ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostCreateNewGameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCreateNewGameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostCreateNewGameWithBodyWithResponse request with arbitrary body returning *PostCreateNewGameResponse
func (c *ClientWithResponses) PostCreateNewGameWithBodyWithResponse(ctx context.Context, params *PostCreateNewGameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateNewGameResponse, error) {
	rsp, err := c.PostCreateNewGameWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateNewGameResponse(rsp)
}

func (c *ClientWithResponses) PostCreateNewGameWithResponse(ctx context.Context, params *PostCreateNewGameParams, body PostCreateNewGameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreateNewGameResponse, error) {
	rsp, err := c.PostCreateNewGame(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateNewGameResponse(rsp)
}

// ParsePostCreateNewGameResponse parses an HTTP response from a PostCreateNewGameWithResponse call
func ParsePostCreateNewGameResponse(rsp *http.Response) (*PostCreateNewGameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCreateNewGameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateNewGameResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /create-new-game)
	PostCreateNewGame(ctx echo.Context, params PostCreateNewGameParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostCreateNewGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostCreateNewGame(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostCreateNewGameParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-REQUEST-SIGN" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-REQUEST-SIGN")]; found {
		var XREQUESTSIGN string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-REQUEST-SIGN, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-REQUEST-SIGN", valueList[0], &XREQUESTSIGN, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-REQUEST-SIGN: %s", err))
		}

		params.XREQUESTSIGN = XREQUESTSIGN
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-REQUEST-SIGN is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCreateNewGame(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/create-new-game", wrapper.PostCreateNewGame)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"4ePj418BAAD//1c7G3v/DwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../common-components.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
