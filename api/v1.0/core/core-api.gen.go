// Package coreapiv1 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package coreapiv1

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
	externalRef0 "github.com/swipegames/public-api/api/v1.0"
)

// Defines values for CreateNewGameRequestPlatform.
const (
	Desktop CreateNewGameRequestPlatform = "desktop"
	Mobile  CreateNewGameRequestPlatform = "mobile"
)

// CancelFreeRoundsRequest defines model for CancelFreeRoundsRequest.
type CancelFreeRoundsRequest struct {
	// Cid Client's ID (internal)
	Cid openapi_types.UUID `json:"cid"`

	// ExtID Free rounds ID (external). Used as idempotency key. One of id or extID must be provided.
	ExtID *string `json:"extID,omitempty"`

	// Id Free rounds ID (internal). Used as idempotency key. One of id or extID must be provided.
	Id *openapi_types.UUID `json:"id,omitempty"`
}

// CancelFreeRoundsResponse defines model for CancelFreeRoundsResponse.
type CancelFreeRoundsResponse struct {
	// ExtID Free rounds ID (external). It always provided on create request.
	ExtID string `json:"extID"`

	// Id Free rounds ID (internal).
	Id openapi_types.UUID `json:"id"`
}

// CreateFreeRoundsRequest defines model for CreateFreeRoundsRequest.
type CreateFreeRoundsRequest struct {
	// BetLine Number of bet line configured for this game/provider.
	BetLine int32 `json:"betLine"`

	// Cid Client's ID (internal)
	Cid openapi_types.UUID `json:"cid"`

	// Currency Currency code in ISO4217
	Currency string `json:"currency"`

	// ExtCID External Client's ID (game aggregator or casino)
	ExtCID string `json:"extCID"`

	// ExtID Free rounds ID (external). Used as idempotency key. Same ID can be used to create free rounds only once.
	ExtID string `json:"extID"`

	// GameID Game's ID
	GameID string `json:"gameID"`

	// Quantity Number of free rounds.
	Quantity int32 `json:"quantity"`

	// UserIDs List of player IDs (external). if null then campaign is available for all players.
	UserIDs *[]string `json:"userIDs,omitempty"`

	// ValidFrom Start date when free rounds become available.
	ValidFrom time.Time `json:"validFrom"`

	// ValidUntil End date when free rounds become unavailable. Could be setup later.
	ValidUntil *time.Time `json:"validUntil,omitempty"`
}

// CreateFreeRoundsResponse defines model for CreateFreeRoundsResponse.
type CreateFreeRoundsResponse struct {
	// ExtID Free rounds ID (external). This is provided in the request.
	ExtID string `json:"extID"`

	// Id Free rounds ID (internal).
	Id openapi_types.UUID `json:"id"`
}

// CreateNewGameRequest defines model for CreateNewGameRequest.
type CreateNewGameRequest struct {
	// CID Client's ID. It's provided by Swipe Games and is used as your identifier.
	CID openapi_types.UUID `json:"cID"`

	// Currency Currency code in ISO4217.
	Currency string `json:"currency"`

	// Demo Demo mode. If true, the game will be launched in demo mode (means no callbacks will be fired on your side,
	// and we use our demo balance for the game). If false, the game will be launched in real mode.
	Demo *bool `json:"demo,omitempty"`

	// ExtCID External Client's ID (client/platform/game aggregator/integrator or casino on your side). This is provided from your side, and this is
	// how you identify your clients. We use it in all callbacks to you. Not required for demo games, since we don't use callbacks for demo games.
	ExtCID *string `json:"extCID,omitempty"`

	// GameID Game's ID. This is Swipe Games's game identifier. See the list of supported games in `Game IDs` section.
	GameID string `json:"gameID"`

	// Language Language code in IIETF BCP 47 (ISO 639).
	Language *string `json:"language,omitempty"`

	// Platform Platform code. This is used to identify the platform where the game is launched.
	Platform *CreateNewGameRequestPlatform `json:"platform,omitempty"`

	// ReturnURL Return URL which we could use to redirect the user after the game is finished/exited. If you don't provide this URL, return button in the game will be disabled. Please make sure you provide this URL when using redirect to open the game, otherwise player cannot
	ReturnURL *string `json:"returnURL,omitempty"`

	// SessionID Session ID (game integrator or casino).This is your Session ID. We use
	// it in all callbacks to you. Not required for demo games, since we don't use callbacks for demo games.
	SessionID *string           `json:"sessionID,omitempty"`
	User      externalRef0.User `json:"user"`
}

// CreateNewGameRequestPlatform Platform code. This is used to identify the platform where the game is launched.
type CreateNewGameRequestPlatform string

// CreateNewGameResponse defines model for CreateNewGameResponse.
type CreateNewGameResponse struct {
	GameSessionID openapi_types.UUID `json:"gameSessionID"`
	GameUrl       string             `json:"gameUrl"`
}

// PostCreateNewGameParams defines parameters for PostCreateNewGame.
type PostCreateNewGameParams struct {
	// XREQUESTSIGN Request signature (read more in the Authentication section)
	XREQUESTSIGN string `json:"X-REQUEST-SIGN"`
}

// PostFreeRoundsParams defines parameters for PostFreeRounds.
type PostFreeRoundsParams struct {
	// XREQUESTSIGN Request signature (read more in the Authentication section)
	XREQUESTSIGN string `json:"X-REQUEST-SIGN"`
}

// PostFreeRoundsCancelParams defines parameters for PostFreeRoundsCancel.
type PostFreeRoundsCancelParams struct {
	// XREQUESTSIGN Request signature (read more in the Authentication section)
	XREQUESTSIGN string `json:"X-REQUEST-SIGN"`
}

// PostCreateNewGameJSONRequestBody defines body for PostCreateNewGame for application/json ContentType.
type PostCreateNewGameJSONRequestBody = CreateNewGameRequest

// PostFreeRoundsJSONRequestBody defines body for PostFreeRounds for application/json ContentType.
type PostFreeRoundsJSONRequestBody = CreateFreeRoundsRequest

// PostFreeRoundsCancelJSONRequestBody defines body for PostFreeRoundsCancel for application/json ContentType.
type PostFreeRoundsCancelJSONRequestBody = CancelFreeRoundsRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// PostCreateNewGameWithBody request with any body
	PostCreateNewGameWithBody(ctx context.Context, params *PostCreateNewGameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCreateNewGame(ctx context.Context, params *PostCreateNewGameParams, body PostCreateNewGameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFreeRoundsWithBody request with any body
	PostFreeRoundsWithBody(ctx context.Context, params *PostFreeRoundsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFreeRounds(ctx context.Context, params *PostFreeRoundsParams, body PostFreeRoundsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFreeRoundsCancelWithBody request with any body
	PostFreeRoundsCancelWithBody(ctx context.Context, params *PostFreeRoundsCancelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFreeRoundsCancel(ctx context.Context, params *PostFreeRoundsCancelParams, body PostFreeRoundsCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) PostCreateNewGameWithBody(ctx context.Context, params *PostCreateNewGameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateNewGameRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreateNewGame(ctx context.Context, params *PostCreateNewGameParams, body PostCreateNewGameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateNewGameRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFreeRoundsWithBody(ctx context.Context, params *PostFreeRoundsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFreeRoundsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFreeRounds(ctx context.Context, params *PostFreeRoundsParams, body PostFreeRoundsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFreeRoundsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFreeRoundsCancelWithBody(ctx context.Context, params *PostFreeRoundsCancelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFreeRoundsCancelRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFreeRoundsCancel(ctx context.Context, params *PostFreeRoundsCancelParams, body PostFreeRoundsCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFreeRoundsCancelRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewPostCreateNewGameRequest calls the generic PostCreateNewGame builder with application/json body
func NewPostCreateNewGameRequest(server string, params *PostCreateNewGameParams, body PostCreateNewGameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCreateNewGameRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCreateNewGameRequestWithBody generates requests for PostCreateNewGame with any type of body
func NewPostCreateNewGameRequestWithBody(server string, params *PostCreateNewGameParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/create-new-game")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-REQUEST-SIGN", runtime.ParamLocationHeader, params.XREQUESTSIGN)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-REQUEST-SIGN", headerParam0)

	}

	return req, nil
}

// NewPostFreeRoundsRequest calls the generic PostFreeRounds builder with application/json body
func NewPostFreeRoundsRequest(server string, params *PostFreeRoundsParams, body PostFreeRoundsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFreeRoundsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostFreeRoundsRequestWithBody generates requests for PostFreeRounds with any type of body
func NewPostFreeRoundsRequestWithBody(server string, params *PostFreeRoundsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/free-rounds")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-REQUEST-SIGN", runtime.ParamLocationHeader, params.XREQUESTSIGN)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-REQUEST-SIGN", headerParam0)

	}

	return req, nil
}

// NewPostFreeRoundsCancelRequest calls the generic PostFreeRoundsCancel builder with application/json body
func NewPostFreeRoundsCancelRequest(server string, params *PostFreeRoundsCancelParams, body PostFreeRoundsCancelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFreeRoundsCancelRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostFreeRoundsCancelRequestWithBody generates requests for PostFreeRoundsCancel with any type of body
func NewPostFreeRoundsCancelRequestWithBody(server string, params *PostFreeRoundsCancelParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/free-rounds/cancel")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-REQUEST-SIGN", runtime.ParamLocationHeader, params.XREQUESTSIGN)
		if err != nil {
			return nil, err
		}

		req.Header.Set("X-REQUEST-SIGN", headerParam0)

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// PostCreateNewGameWithBodyWithResponse request with any body
	PostCreateNewGameWithBodyWithResponse(ctx context.Context, params *PostCreateNewGameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateNewGameResponse, error)

	PostCreateNewGameWithResponse(ctx context.Context, params *PostCreateNewGameParams, body PostCreateNewGameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreateNewGameResponse, error)

	// PostFreeRoundsWithBodyWithResponse request with any body
	PostFreeRoundsWithBodyWithResponse(ctx context.Context, params *PostFreeRoundsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFreeRoundsResponse, error)

	PostFreeRoundsWithResponse(ctx context.Context, params *PostFreeRoundsParams, body PostFreeRoundsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFreeRoundsResponse, error)

	// PostFreeRoundsCancelWithBodyWithResponse request with any body
	PostFreeRoundsCancelWithBodyWithResponse(ctx context.Context, params *PostFreeRoundsCancelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFreeRoundsCancelResponse, error)

	PostFreeRoundsCancelWithResponse(ctx context.Context, params *PostFreeRoundsCancelParams, body PostFreeRoundsCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFreeRoundsCancelResponse, error)
}

type PostCreateNewGameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateNewGameResponse
	JSON401      *externalRef0.ErrorResponse
	JSON500      *externalRef0.ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostCreateNewGameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCreateNewGameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFreeRoundsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateFreeRoundsResponse
	JSON401      *externalRef0.ErrorResponse
	JSON409      *externalRef0.ErrorResponse
	JSON500      *externalRef0.ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostFreeRoundsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFreeRoundsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFreeRoundsCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CancelFreeRoundsResponse
	JSON401      *externalRef0.ErrorResponse
	JSON404      *externalRef0.ErrorResponse
	JSON500      *externalRef0.ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostFreeRoundsCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFreeRoundsCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// PostCreateNewGameWithBodyWithResponse request with arbitrary body returning *PostCreateNewGameResponse
func (c *ClientWithResponses) PostCreateNewGameWithBodyWithResponse(ctx context.Context, params *PostCreateNewGameParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateNewGameResponse, error) {
	rsp, err := c.PostCreateNewGameWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateNewGameResponse(rsp)
}

func (c *ClientWithResponses) PostCreateNewGameWithResponse(ctx context.Context, params *PostCreateNewGameParams, body PostCreateNewGameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreateNewGameResponse, error) {
	rsp, err := c.PostCreateNewGame(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateNewGameResponse(rsp)
}

// PostFreeRoundsWithBodyWithResponse request with arbitrary body returning *PostFreeRoundsResponse
func (c *ClientWithResponses) PostFreeRoundsWithBodyWithResponse(ctx context.Context, params *PostFreeRoundsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFreeRoundsResponse, error) {
	rsp, err := c.PostFreeRoundsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFreeRoundsResponse(rsp)
}

func (c *ClientWithResponses) PostFreeRoundsWithResponse(ctx context.Context, params *PostFreeRoundsParams, body PostFreeRoundsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFreeRoundsResponse, error) {
	rsp, err := c.PostFreeRounds(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFreeRoundsResponse(rsp)
}

// PostFreeRoundsCancelWithBodyWithResponse request with arbitrary body returning *PostFreeRoundsCancelResponse
func (c *ClientWithResponses) PostFreeRoundsCancelWithBodyWithResponse(ctx context.Context, params *PostFreeRoundsCancelParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFreeRoundsCancelResponse, error) {
	rsp, err := c.PostFreeRoundsCancelWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFreeRoundsCancelResponse(rsp)
}

func (c *ClientWithResponses) PostFreeRoundsCancelWithResponse(ctx context.Context, params *PostFreeRoundsCancelParams, body PostFreeRoundsCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFreeRoundsCancelResponse, error) {
	rsp, err := c.PostFreeRoundsCancel(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFreeRoundsCancelResponse(rsp)
}

// ParsePostCreateNewGameResponse parses an HTTP response from a PostCreateNewGameWithResponse call
func ParsePostCreateNewGameResponse(rsp *http.Response) (*PostCreateNewGameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCreateNewGameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateNewGameResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostFreeRoundsResponse parses an HTTP response from a PostFreeRoundsWithResponse call
func ParsePostFreeRoundsResponse(rsp *http.Response) (*PostFreeRoundsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFreeRoundsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateFreeRoundsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest externalRef0.ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostFreeRoundsCancelResponse parses an HTTP response from a PostFreeRoundsCancelWithResponse call
func ParsePostFreeRoundsCancelResponse(rsp *http.Response) (*PostFreeRoundsCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFreeRoundsCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CancelFreeRoundsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest externalRef0.ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest externalRef0.ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest externalRef0.ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

	// (POST /create-new-game)
	PostCreateNewGame(ctx echo.Context, params PostCreateNewGameParams) error

	// (POST /free-rounds)
	PostFreeRounds(ctx echo.Context, params PostFreeRoundsParams) error
	// Cancel Free Rounds
	// (POST /free-rounds/cancel)
	PostFreeRoundsCancel(ctx echo.Context, params PostFreeRoundsCancelParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// PostCreateNewGame converts echo context to params.
func (w *ServerInterfaceWrapper) PostCreateNewGame(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostCreateNewGameParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-REQUEST-SIGN" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-REQUEST-SIGN")]; found {
		var XREQUESTSIGN string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-REQUEST-SIGN, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-REQUEST-SIGN", valueList[0], &XREQUESTSIGN, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-REQUEST-SIGN: %s", err))
		}

		params.XREQUESTSIGN = XREQUESTSIGN
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-REQUEST-SIGN is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostCreateNewGame(ctx, params)
	return err
}

// PostFreeRounds converts echo context to params.
func (w *ServerInterfaceWrapper) PostFreeRounds(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostFreeRoundsParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-REQUEST-SIGN" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-REQUEST-SIGN")]; found {
		var XREQUESTSIGN string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-REQUEST-SIGN, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-REQUEST-SIGN", valueList[0], &XREQUESTSIGN, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-REQUEST-SIGN: %s", err))
		}

		params.XREQUESTSIGN = XREQUESTSIGN
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-REQUEST-SIGN is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFreeRounds(ctx, params)
	return err
}

// PostFreeRoundsCancel converts echo context to params.
func (w *ServerInterfaceWrapper) PostFreeRoundsCancel(ctx echo.Context) error {
	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params PostFreeRoundsCancelParams

	headers := ctx.Request().Header
	// ------------- Required header parameter "X-REQUEST-SIGN" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-REQUEST-SIGN")]; found {
		var XREQUESTSIGN string
		n := len(valueList)
		if n != 1 {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Expected one value for X-REQUEST-SIGN, got %d", n))
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-REQUEST-SIGN", valueList[0], &XREQUESTSIGN, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter X-REQUEST-SIGN: %s", err))
		}

		params.XREQUESTSIGN = XREQUESTSIGN
	} else {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Header parameter X-REQUEST-SIGN is required, but not found"))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.PostFreeRoundsCancel(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.POST(baseURL+"/create-new-game", wrapper.PostCreateNewGame)
	router.POST(baseURL+"/free-rounds", wrapper.PostFreeRounds)
	router.POST(baseURL+"/free-rounds/cancel", wrapper.PostFreeRoundsCancel)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xZbW/bOBL+KwPtAUkAvyRNrovmWzcvhYEgzcUN9g5N0dDSSOaGIlW+xDGK/vfDkJIt",
	"RXTabrO7LdBPrUVq5uHMM/MMlY9JqspKSZTWJIcfE5POsWT+v0dMpihONeKlcjIzl/jBobG0VGlVobYc",
	"/caUZ/RPhibVvLJcyeQwORIcpd0yMDmGbS4tasnETjJIcqVLZpPDxDmeJYPELitMDhNjNZdF8mmQ4L2d",
	"HPcNEhDQHom3ife1zRFcGcyAGeAZlpWyKNMl3OJyBK8lgsqBZ6A0eLtQOmNhhlBpdcczzEbXMgYidqSH",
	"CFanegoEnwnLp0Gi8YPjGrPk8K0P+bvVJjX7A1NLsPs5M5WSBvtJ+/ooTywwsWBLs0IOSkKqkVkEHcgx",
	"+vZYfnUs/JZwnGhIPMAvoPEM7RmX2Md67soZakrjDC0ILhFSJXNeOI0Z5EqDnXMDBStxXIdGd47Bpd1/",
	"lgySkt3z0pXJ4YsXg6TkMvzYW4GmIBSoCfUT11TqtCZSRmzWK5CqDIFLmExfHzzb+3VDZR7FSHNSkwQ6",
	"ACkewIpCY8Gs0lQAKTNcqp2/uOqn5HhyDCmTVGeO9lnVMDVvWVRSLEHJFDd0ATpCDNUrVqI/ZeylD45J",
	"y+3yMSK1QHwrU5xBPTk2fW9n3FjyVQm2RA2TY9MJH89BOiHAzlFCysqK8UICN8DuGBdsJtBTmwlRW/BI",
	"ucXS++odu37AtGZL+n3HBM9OtSr7yKaWaQsZZWNB3tspmWGqiDcNiE546JWh5SXG4u4dXknLRYShMnvc",
	"n5Nrj3CknMiIOgatq0Awi/pBl34ESaRVN/ReldCKWq3SbDFnsGpG7Th+WXd7uob/hroab7V7Lokt332v",
	"P8cFFejmeSUWh1brIqnbah17toTpglcIZNUAkxlFxdXtZ6mcph4kLc95jydP15Cj4c6wVH0Tx1gqKFWG",
	"I5jkYLXDgU+c78gLLgRxWzAn03nIata8ANslMmlAKkiZEDOW3prVGzllgTTfH9nwDAfXkqKx8E0W6Km3",
	"NGOC5pBaGoPfHY8lZ8J8DoxGJgL6dlOeKSWQya+XodT/GFeCWcrK+IEsjX0r1V2F6hwyVgm5VmUrDJ4T",
	"Nmy6lnO1oLWGFMuwMeAwI/g9RItbOiy113WkraK9IzhXFhra+yj6sBJyMwDDKbYLhEzJLettrS10N/9Z",
	"WVufuEX8rTDitLkOU0SfTFFrjXFVpbTFLPinE968CnJsbsBgSp42oBJMFo4VkQHsrF5Zl8Tk5M0p/HZ0",
	"AQe/wvZk+hqe77/YiVZIk/e+1Yt6xVtdn7gZF1bZo/M1Vkg/NK75y82KuuQdJcn0W3J0a1VFQq5mXGCr",
	"Wa2RabROy6vLsz60S78EV5dnsJjzdE7ZTr0oUbatAo0Z15haj4QmAGC5Rd0BlnPJzRyzMd5zi5mvP6Jl",
	"oE1N5cDaq8uzAQQ8MHPWKtn0+k6VZtyQQGYjuBDIDELJbhGM0+gNPzQZxNYZLosWYAWqwrXxASg7R73g",
	"BptJJWVSKhtLpkFjuJIx7k7D0nryjNX1zqjJsi/J9TtNVV7Lf7AsKY90sH9pzJPD5Jfx+mo+ru/lY1bx",
	"93d7o933qSpLJYfrLe+v6PXe9NEdNryLzswhVMo6BN2oppsGCzI+bSfms+JHb1xpERkjH6BvNg4eOImh",
	"fSQyJ1or3T7AA8X1LwDSLtD1Np+ytuxfuJngKby8mFCld0OQoWVcRGbwN5jOJU+ZgHrLShO9t9ao6dtO",
	"oMnMFQWXxQDM3K9K5b8XmLlaSOJiU/PRfleiMdEm+hJmmmMOrafUsVdYiPYnshDczNsT8Bc4fZC0BsFg",
	"FZavTNdVXQcPpjblpNWxgSksBHEgLdjfe/58uAdMVHM2fBaNUs61seesxOhVJjbEEqit7ojs0+WnldDI",
	"mrm2W+1xWRLsEf+Sp7cbFvvzcD+4tInL3A+GlltBaxEmHymNRGe6Y6A24Zh7o93RLmGgJs0qnhwm+6Pd",
	"0T5Rntm5z8Q43KSHEhfDooZZqTBp94IW1KC+MrSu4QwkLnyA/JcljQU3FrXxj28oejfUt28ovjdBhlRQ",
	"DYP6jgRPZrVkGf/4LOiwJuW5lu3RcwT/U85/DejLpmd2LVdWgfE3U9IhEq2VAJKGkGgFceCnmqxey0tk",
	"GZQURjZTznYgNAL6tv3w3fYvgjn6NXRa7HQHIiI7o5+TjKYTZWynAfsMkGOKUnL4tj8zhBAbXkhmSZO3",
	"9QpfDealo9u+5an307jfoXs9mZgjy7w+SJ/V5L/Dy5P/XJ1M3wynk1fnSZt6/lJRfy2O0fRd2IzG/qay",
	"ZahfaVF6krCqEjWG8R+G0H9smXpM/qIXvE/dqiBo/kFo5J6yz3Z3/yoMtap4EN2MqFsqpIPdvSdz/cUa",
	"F0Hzu1ayaLFDaSp+uEX/tebfTxigb0E5DcUdFEmlflDJaOOnQTLONeIwfEjY3HNCenwbaX/nab5wRQtt",
	"/f3kZ5WtGN7/ZP6PFFrk29YPXmsHuy++C5SnkfIAJojPS8B7bqz5EVvDOPV/BHukQ/j1cEKS+T/RJoKJ",
	"n82CqnTDn4n/7max6S+fP3yzOPh+mwXdTHN69iP0iUFiXFkyukI2LcAfaiX8lhVUxUn76TvqL/8PAAD/",
	"/96ay84lIQAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	for rawPath, rawFunc := range externalRef0.PathToRawSpec(path.Join(path.Dir(pathToFile), "../common-components.yaml")) {
		if _, ok := res[rawPath]; ok {
			// it is not possible to compare functions in golang, so always overwrite the old value
		}
		res[rawPath] = rawFunc
	}
	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
